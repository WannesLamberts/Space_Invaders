<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Binary formats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Binary formats </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="images/binary.png" alt="conversion between JSON and binary formats" class="inline"/></p>
<p>Several formats exist that encode JSON values in a binary format to reduce the size of the encoded value as well as the required effort to parse encoded value. The library implements three formats, namely</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7049">CBOR</a> (Concise Binary Object Representation)</li>
<li><a href="https://msgpack.org">MessagePack</a></li>
<li><a href="http://ubjson.org">UBJSON</a> (Universal Binary JSON)</li>
</ul>
<h1><a class="anchor" id="autotoc_md90"></a>
Interface</h1>
<h2><a class="anchor" id="autotoc_md91"></a>
JSON to binary format</h2>
<p>For each format, the <code>to_*</code> functions (i.e., <code>to_cbor</code>, <code>to_msgpack</code>, and <code>to_ubjson</code>) convert a JSON value into the respective binary format. Taking CBOR as example, the concrete prototypes are:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> std::vector&lt;uint8_t&gt; to_cbor(<span class="keyword">const</span> basic_json&amp; j);                    <span class="comment">// 1</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> to_cbor(<span class="keyword">const</span> basic_json&amp; j, detail::output_adapter&lt;uint8_t&gt; o); <span class="comment">// 2</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> to_cbor(<span class="keyword">const</span> basic_json&amp; j, detail::output_adapter&lt;char&gt; o);    <span class="comment">// 3</span></div>
</div><!-- fragment --><p>The first function creates a byte vector from the given JSON value. The second and third function writes to an output adapter of <code>uint8_t</code> and <code>char</code>, respectively. Output adapters are implemented for strings, output streams, and vectors.</p>
<p>Given a JSON value <code>j</code>, the following calls are possible:</p>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; v;</div>
<div class="line">v = <a class="code" href="classnlohmann_1_1basic__json.html#a2566783e190dec524bf3445b322873b8">json::to_cbor</a>(j);   <span class="comment">// 1</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html#a2566783e190dec524bf3445b322873b8">json::to_cbor</a>(j, v);    <span class="comment">// 2</span></div>
<div class="line"> </div>
<div class="line">std::string s;</div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html#a2566783e190dec524bf3445b322873b8">json::to_cbor</a>(j, s);    <span class="comment">// 3</span></div>
<div class="line"> </div>
<div class="line">std::ostringstream oss;</div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html#a2566783e190dec524bf3445b322873b8">json::to_cbor</a>(j, oss);  <span class="comment">// 3</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md92"></a>
Binary format to JSON</h2>
<p>Likewise, the <code>from_*</code> functions (i.e, <code>from_cbor</code>, <code>from_msgpack</code>, and <code>from_ubjson</code>) convert a binary encoded value into a JSON value. Taking CBOR as example, the concrete prototypes are:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> basic_json from_cbor(detail::input_adapter i, <span class="keyword">const</span> <span class="keywordtype">bool</span> strict = <span class="keyword">true</span>); <span class="comment">// 1</span></div>
<div class="line"><span class="keyword">static</span> basic_json from_cbor(A1 &amp;&amp; a1, A2 &amp;&amp; a2, <span class="keyword">const</span> <span class="keywordtype">bool</span> strict = <span class="keyword">true</span>);      <span class="comment">// 2</span></div>
</div><!-- fragment --><p>Both functions read from an input adapter: the first function takes it directly form argument <code>i</code>, whereas the second function creates it from the provided arguments <code>a1</code> and <code>a2</code>. If the optional parameter <code>strict</code> is true, the input must be read completely (or a parse error exception is thrown). If it is false, parsing succeeds even if the input is not completely read.</p>
<p>Input adapters are implemented for input streams, character buffers, string literals, and iterator ranges.</p>
<p>Given several inputs (which we assume to be filled with a CBOR value), the following calls are possible:</p>
<div class="fragment"><div class="line">std::string s;</div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html">json</a> j1 = <a class="code" href="classnlohmann_1_1basic__json.html#a1d568ba1bd6978d80db42aa76626e2cf">json::from_cbor</a>(s);                         <span class="comment">// 1</span></div>
<div class="line"> </div>
<div class="line">std::ifstream is(<span class="stringliteral">&quot;somefile.cbor&quot;</span>, std::ios::binary);</div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html">json</a> j2 = <a class="code" href="classnlohmann_1_1basic__json.html#a1d568ba1bd6978d80db42aa76626e2cf">json::from_cbor</a>(is);                        <span class="comment">// 1</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;uint8_t&gt; v;</div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html">json</a> j3 = <a class="code" href="classnlohmann_1_1basic__json.html#a1d568ba1bd6978d80db42aa76626e2cf">json::from_cbor</a>(v);                         <span class="comment">// 1</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* buff;</div>
<div class="line">std::size_t buff_size;</div>
<div class="line"><a class="code" href="classnlohmann_1_1basic__json.html">json</a> j4 = <a class="code" href="classnlohmann_1_1basic__json.html#a1d568ba1bd6978d80db42aa76626e2cf">json::from_cbor</a>(buff, buff_size);           <span class="comment">// 2</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md93"></a>
Details</h1>
<h2><a class="anchor" id="autotoc_md94"></a>
CBOR</h2>
<p>The mapping from CBOR to JSON is <b>incomplete</b> in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors (parse_error.112):</p>
<ul>
<li>byte strings (0x40..0x5F)</li>
<li>date/time (0xC0..0xC1)</li>
<li>bignum (0xC2..0xC3)</li>
<li>decimal fraction (0xC4)</li>
<li>bigfloat (0xC5)</li>
<li>tagged items (0xC6..0xD4, 0xD8..0xDB)</li>
<li>expected conversions (0xD5..0xD7)</li>
<li>simple values (0xE0..0xF3, 0xF8)</li>
<li>undefined (0xF7)</li>
</ul>
<p>CBOR further allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected (parse_error.113).</p>
<p>The mapping from JSON to CBOR is <b>complete</b> in the sense that any JSON value type can be converted to a CBOR value.</p>
<p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the dump() function which serializes NaN or Infinity to null.</p>
<p>The following CBOR types are not used in the conversion:</p>
<ul>
<li>byte strings (0x40..0x5F)</li>
<li>UTF-8 strings terminated by "break" (0x7F)</li>
<li>arrays terminated by "break" (0x9F)</li>
<li>maps terminated by "break" (0xBF)</li>
<li>date/time (0xC0..0xC1)</li>
<li>bignum (0xC2..0xC3)</li>
<li>decimal fraction (0xC4)</li>
<li>bigfloat (0xC5)</li>
<li>tagged items (0xC6..0xD4, 0xD8..0xDB)</li>
<li>expected conversions (0xD5..0xD7)</li>
<li>simple values (0xE0..0xF3, 0xF8)</li>
<li>undefined (0xF7)</li>
<li>half and single-precision floats (0xF9-0xFA)</li>
<li>break (0xFF)</li>
</ul>
<h2><a class="anchor" id="autotoc_md95"></a>
MessagePack</h2>
<p>The mapping from MessagePack to JSON is <b>incomplete</b> in the sense that not all MessagePack types can be converted to a JSON value. The following MessagePack types are not supported and will yield parse errors:</p>
<ul>
<li>bin 8 - bin 32 (0xC4..0xC6)</li>
<li>ext 8 - ext 32 (0xC7..0xC9)</li>
<li>fixext 1 - fixext 16 (0xD4..0xD8)</li>
</ul>
<p>The mapping from JSON to MessagePack is <b>complete</b> in the sense that any JSON value type can be converted to a MessagePack value.</p>
<p>The following values can not be converted to a MessagePack value:</p>
<ul>
<li>strings with more than 4294967295 bytes</li>
<li>arrays with more than 4294967295 elements</li>
<li>objects with more than 4294967295 elements</li>
</ul>
<p>The following MessagePack types are not used in the conversion:</p>
<ul>
<li>bin 8 - bin 32 (0xC4..0xC6)</li>
<li>ext 8 - ext 32 (0xC7..0xC9)</li>
<li>float 32 (0xCA)</li>
<li>fixext 1 - fixext 16 (0xD4..0xD8)</li>
</ul>
<p>Any MessagePack output created <code>to_msgpack</code> can be successfully parsed by <code>from_msgpack</code>.</p>
<p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the <code>dump()</code> function which serializes NaN or Infinity to <code>null</code>.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
UBJSON</h2>
<p>The mapping from UBJSON to JSON is <b>complete</b> in the sense that any UBJSON value can be converted to a JSON value.</p>
<p>The mapping from JSON to UBJSON is <b>complete</b> in the sense that any JSON value type can be converted to a UBJSON value.</p>
<p>The following values can not be converted to a UBJSON value:</p>
<ul>
<li>strings with more than 9223372036854775807 bytes (theoretical)</li>
<li>unsigned integer numbers above 9223372036854775807</li>
</ul>
<p>The following markers are not used in the conversion:</p>
<ul>
<li><code>Z</code>: no-op values are not created.</li>
<li><code>C</code>: single-byte strings are serialized with S markers.</li>
</ul>
<p>Any UBJSON output created to_ubjson can be successfully parsed by from_ubjson.</p>
<p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the <code>dump()</code> function which serializes NaN or Infinity to null.</p>
<p>The optimized formats for containers are supported: Parameter <code>use_size</code> adds size information to the beginning of a container and removes the closing marker. Parameter <code>use_type</code> further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The <code>use_type</code> parameter must only be used together with <code>use_size = true</code>. Note that <code>use_size = true</code> alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container.</p>
<h1><a class="anchor" id="autotoc_md97"></a>
Size comparison examples</h1>
<p>The following table shows the size compared to the original JSON value for different files from the repository for the different formats.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">format  </th><th class="markdownTableHeadRight">sample.json  </th><th class="markdownTableHeadRight">all_unicode.json  </th><th class="markdownTableHeadRight">floats.json  </th><th class="markdownTableHeadRight">signed_ints.json  </th><th class="markdownTableHeadRight">jeopardy.json  </th><th class="markdownTableHeadRight">canada.json   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">JSON  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CBOR  </td><td class="markdownTableBodyRight">87.21 %  </td><td class="markdownTableBodyRight">71.18 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">87.96 %  </td><td class="markdownTableBodyRight">50.53 %   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MessagePack  </td><td class="markdownTableBodyRight">87.16 %  </td><td class="markdownTableBodyRight">71.18 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">87.91 %  </td><td class="markdownTableBodyRight">50.56 %   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UBJSON unoptimized  </td><td class="markdownTableBodyRight">88.15 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">96.58 %  </td><td class="markdownTableBodyRight">53.20 %   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UBJSON size-optimized  </td><td class="markdownTableBodyRight">89.26 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">97.40 %  </td><td class="markdownTableBodyRight">58.56 %   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UBJSON format-optimized  </td><td class="markdownTableBodyRight">89.45 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">42.85 %  </td><td class="markdownTableBodyRight">39.26 %  </td><td class="markdownTableBodyRight">94.96 %  </td><td class="markdownTableBodyRight">55.93 %   </td></tr>
</table>
<p>The results show that there does not exist a "best" encoding. Furthermore, it is not always worthwhile to use UBJSON's optimizations. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a2566783e190dec524bf3445b322873b8"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a2566783e190dec524bf3445b322873b8">nlohmann::basic_json::to_cbor</a></div><div class="ttdeci">static std::vector&lt; uint8_t &gt; to_cbor(const basic_json &amp;j)</div><div class="ttdoc">create a CBOR serialization of a given JSON value</div><div class="ttdef"><b>Definition:</b> <a href="include_2nlohmann_2json_8hpp_source.html#l06575">json.hpp:6575</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html"><div class="ttname"><a href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a></div><div class="ttdoc">a class to store JSON values</div><div class="ttdef"><b>Definition:</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00165">json.hpp:165</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a1d568ba1bd6978d80db42aa76626e2cf"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a1d568ba1bd6978d80db42aa76626e2cf">nlohmann::basic_json::from_cbor</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_cbor(detail::input_adapter &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">create a JSON value from an input in CBOR format</div><div class="ttdef"><b>Definition:</b> <a href="include_2nlohmann_2json_8hpp_source.html#l06974">json.hpp:6974</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
