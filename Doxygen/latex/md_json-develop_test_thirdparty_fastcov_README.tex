A massively parallel gcov wrapper for generating intermediate coverage formats {\itshape fast}

The goal of fastcov is to generate code coverage intermediate formats {\itshape as fast as possible} (ideally $<$ 1 second), even for large projects with hundreds of gcda objects. The intermediate formats may then be consumed by a report generator such as lcov\textquotesingle{}s genhtml, or a dedicated front end such as coveralls. fastcov was originally designed to be a drop-\/in replacement for lcov (application coverage only, not kernel coverage).

Currently the only intermediate formats supported are gcov json format and lcov info format. Adding support for other formats should require just a few lines of python to transform gcov json format to the desired shape.

In order to achieve the massive speed gains, a few constraints apply\+:


\begin{DoxyEnumerate}
\item G\+CC version $>$= 9.\+0.\+0
\end{DoxyEnumerate}

These versions of G\+C\+OV have support for J\+S\+ON intermediate format as well as streaming report data straight to stdout


\begin{DoxyEnumerate}
\item Object files must be either be built\+:
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item Using absolute paths for all {\ttfamily -\/I} flags passed to the compiler
\item Invoking the compiler from the same root directory
\end{DoxyItemize}

If you use C\+Make, you are almost certainly satisfying the second constraint (unless you care about {\ttfamily External\+Project} coverage).\hypertarget{md_json-develop_test_thirdparty_fastcov_README_autotoc_md213}{}\doxysection{Sample Usage\+:}\label{md_json-develop_test_thirdparty_fastcov_README_autotoc_md213}

\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cd build\_dir}
\DoxyCodeLine{\$ fastcov.py -\/-\/zerocounters}
\DoxyCodeLine{\$ <run unit tests>}
\DoxyCodeLine{\$ fastcov.py -\/-\/exclude /usr/include -\/-\/lcov -\/o report.info}
\DoxyCodeLine{\$ genhtml -\/o code\_coverage report.info}
\end{DoxyCode}
\hypertarget{md_json-develop_test_thirdparty_fastcov_README_autotoc_md214}{}\doxysection{Legacy fastcov}\label{md_json-develop_test_thirdparty_fastcov_README_autotoc_md214}
It is possible to reap most of the benefits of fastcov for G\+CC version $<$ 9.\+0.\+0 and $>$= 7.\+1.\+0. However, there will be a {\itshape potential} header file loss of correctness.

{\ttfamily fastcov\+\_\+legacy.\+py} can be used with pre G\+C\+C-\/9 down to G\+CC 7.\+1.\+0 but with a few penalties due to gcov limitations. This is because running gcov in parallel generates .gcov header reports in parallel which overwrite each other. This isn\textquotesingle{}t a problem unless your header files have actual logic (i.\+e. header only library) that you want to measure coverage for. Use the {\ttfamily -\/F} flag to specify which gcda files should not be run in parallel in order to capture accurate header file data just for those. I don\textquotesingle{}t plan on supporting {\ttfamily fastcov\+\_\+legacy.\+py} aside from basic bug fixes.\hypertarget{md_json-develop_test_thirdparty_fastcov_README_autotoc_md215}{}\doxysection{Benchmarks}\label{md_json-develop_test_thirdparty_fastcov_README_autotoc_md215}
Anecdotal testing on my own projects indicate that fastcov is over 100x faster than lcov and over 30x faster than gcovr\+:

Project Size\+: $\sim$250 .gcda, $\sim$500 .gcov generated by gcov

Time to process all gcda and parse all gcov\+:


\begin{DoxyItemize}
\item fastcov\+: $\sim$700ms
\item lcov\+: $\sim$90s
\item gcovr\+: $\sim$30s 
\end{DoxyItemize}